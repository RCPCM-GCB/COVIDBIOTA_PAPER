
plot_pheatmap_phyloseq <- function (ps_obj, taxa_name_func, transpose = F, ...){
  otu_matrix <- as(otu_table(ps_obj), 'matrix')
  taxa_matrix <- as(tax_table(ps_obj), 'matrix')
  taxa_matrix_good_names <- apply(taxa_matrix, MARGIN=1, taxa_name_func)
  ps_meta <- as(sample_data(ps_obj), 'matrix')
  colnames(otu_matrix) <- taxa_matrix_good_names
  
  if (transpose == T) {
    otu_matrix <- t(otu_matrix)
  }
  
  p <- pheatmap(otu_matrix, ...)
  return(p)
}

prepare_count_table <- function (ps_obj, taxa_name_func) {
  otu_matrix <- as(otu_table(ps_obj), 'matrix')
  taxa_matrix <- as(tax_table(ps_obj), 'matrix')
  taxa_matrix_good_names <- apply(taxa_matrix, MARGIN=1, taxa_name_func)
  # ps_meta <- as(sample_data(ps_obj), 'matrix')
  colnames(otu_matrix) <- taxa_matrix_good_names
  return(otu_matrix)
}

plot_boxplots <- function (ps, f1, f2, level, log = FALSE){
  if (log) {
    ps <- transform_sample_counts(ps, function(x) log(x + 1))
  }
  
  if(taxa_are_rows(ps)){
    otu_t <- t(as.data.frame(otu_table(ps)))
  }
  else {
    otu_t <- as.data.frame(otu_table(ps))
  }
  sample_meta <- as(sample_data(ps), 'matrix')
  meta_w_otu <- merge(otu_t, sample_meta, by.x=0, by.y=0)
  taxa_names <- as.matrix(tax_table(ps))
  
  cols <- colnames(otu_t)
  print(meta_w_otu)
  for (col in cols) {
    # print(paste(col, "~ ", feature_name, sep=''))
    # boxplot(as.formula(paste(col, "~ ", feature_name, sep='')), data = meta_w_otu, main = tt[col, 'Phylum'])
    # 
    print(ggplot(meta_w_otu, aes_string(x=f1, y=col, fill=f2)) +
      geom_boxplot() +
      geom_jitter(width=0.1,alpha=0.2) +
      facet_wrap(as.formula(paste('~',f2))) + ggtitle(taxa_names[col, level]))
    
  }
}

remove_batch_limma <- function(ps, batch_feature){
  
}

generate_prevelance_df <- function(ps0){
  # Compute prevalence of each feature, store as data.frame
  prevdf = apply(X = otu_table(ps0),
                 MARGIN = ifelse(taxa_are_rows(ps0), yes = 1, no = 2),
                 FUN = function(x){sum(x > 0)})
  # Add taxonomy and total read counts to this data.frame
  prevdf = data.frame(Prevalence = prevdf,
                      TotalAbundance = taxa_sums(ps0),
                      tax_table(ps0))
  return (prevdf)
}


adonis2_test <- function(ps_o, method, distance, feature_name) {
  metadata <- as(sample_data(ps_o), "data.frame")
  # calculate distance
  dist = phyloseq::distance(ps_o, method=distance)
  ordination = ordinate(ps_o, method=method, distance=dist)
  ado <- adonis2(as.formula(paste('dist', feature_name, sep=' ~ ')), data = metadata)
  #ano<-anosim(dist ~ diagnosis, data = metadata)
  #ano
  return(ado)
}


ggpdrare <- function(physeq, step = 10, label = NULL, color = NULL,
                     log = TRUE,
                     replace = FALSE, se = TRUE, plot = TRUE, parallel = FALSE) {
  ## Args:
  ## - physeq: phyloseq class object, from which abundance data are extracted
  ## - step: Step size for sample size in rarefaction curves
  ## - label: Default `NULL`. Character string. The name of the variable
  ##          to map to text labels on the plot. Similar to color option
  ##          but for plotting text.
  ## - color: (Optional). Default 'NULL'. Character string. The name of the
  ##          variable to map to colors in the plot. This can be a sample
  ##          variable (among the set returned by
  ##          'sample_variables(physeq)' ) or taxonomic rank (among the set
  ##          returned by 'rank_names(physeq)').
  ##          Finally, The color scheme is chosen automatically by
  ##          'link{ggplot}', but it can be modified afterward with an
  ##          additional layer using 'scale_color_manual'.
  ## - log:   (Otional). Default 'TRUE'. Logical value. Should sample size
  ##          be represented using a log10 scale?
  ## - replace: If TRUE, population are treated as of infinite size, with probabilities of occurence
  ##            of a taxa computed from the (finite size) community data
  ## - se  : Logical, should standard error be computed in addition to expected pd
  ## - plot:  Logical, should the graphic be plotted.
  x <- as(otu_table(physeq), "matrix")
  if (taxa_are_rows(physeq)) { x <- t(x) }
  phy <- phy_tree(physeq)
  
  ## Construct incidence matrix of the tree
  incidence <- incidenceMatrix(phy)
  
  nedges <- nrow(phy$edge)
  ## Order incidence matrix according to community tables and create
  ## community phylogenetic matrix
  incidence <- incidence[colnames(x), ]
  cpm <- x %*% incidence
  if (se) {
    cat("Preliminary computations for se, may take some time\n")
    cpm.var <- array(NA, dim = c(nedges, nedges, nrow(x)))
    cpm.var.fun <- function(i) {
      union.clade <- incidence[, i] + incidence
      union.clade[union.clade > 0] <- 1
      union.clade <- t(x %*% union.clade)
      ## union.clade[s, j] is the number of individuals in subtrees
      ## generated by cutting branches i (from outer loop) and j
      ## in sample s
      return(union.clade)
    }
    for (i in seq_len(nedges)) {
      if (i %% 100 == 0) {
        cat(paste("Cutting edge", i, "out of", nedges), sep = "\n")
      }
      cpm.var[i, , ] <- cpm.var.fun(i)
    }
    ## Deprecated code, need to work on a better parallel version
    ## if (parallel) {
    ##     cpm.var <- mclapply(seq_len(nedges), cpm.var.fun, mc.preschedule = TRUE)
    ## } else {
    ##     cpm.var <- lapply(seq_len(nedges), cpm.var.fun)
    ## }
    ## cpm.var <- do.call(rbind, cpm.var)
    ## dim(cpm.var) <- c(nedges, nedges, nrow(x))
    dimnames(cpm.var) <- list(phy$edge[, 2], phy$edge[, 2], rownames(x))
  }
  
  ## Compute overall Phylogenetic Diversity
  pd <-  (0 + (cpm > 0) ) %*% phy$edge.length
  
  
  ## Transform community matrices to frequency data
  tot <- rowSums(x)
  nr <- nrow(x)
  ## Rarefy phylogenetic diversity for one sample (i)
  pdrare <- function(i) {
    cat(paste("rarefying sample", rownames(x)[i]), sep = "\n")
    ## Simplify matrices and tree to remove unnecessary computations.
    edges.to.keep <- cpm[i, ] > 0
    branch.lengths <- phy$edge.length[edges.to.keep]
    cpm.i <- cpm[i, edges.to.keep]
    if (se) {
      cpm.var.i <- cpm.var[ edges.to.keep, edges.to.keep, i]
    }
    ## sequence of sample sizes
    n <- seq(1, tot[i], by = step)
    if (n[length(n)] != tot[i])
      n <- c(n, tot[i])
    ## Mean and variance of pd for different sample sizes
    ## Start with mean
    if (replace) {
      ## Expected cpm
      cpm.rare <- 1 - t(outer((1 - cpm.i/tot[i]), n, "^"))
    } else {
      ## use lchoose instead of choose for numeric stability
      cpm.rare <-  outer(tot[i] - cpm.i, n, lchoose)
      cpm.rare <- sweep(cpm.rare, 2, lchoose(tot[i], n), FUN = "-")
      cpm.rare <- t(1 - exp(cpm.rare))
    }
    pd.rare <- as.vector(cpm.rare %*% branch.lengths)
    ## Continue with se, if necessary
    if (se) {
      cat(paste("Compute se for sample", rownames(x)[i], ", may take some time"), sep = "\n")
      ## Variance of cpm, computed via a loop to optimize memory use
      centering <-  (1 - cpm.rare) %*% branch.lengths
      pd.rare.var <- rep(NA, length(n))
      for (index in seq_along(n)) {
        size <- n[index]
        if (replace) {
          cpm.var.rare <- (1 - cpm.var.i/tot[i])^size
        } else {
          ## use lchoose instead of choose for numeric stability
          cpm.var.rare <- lchoose(tot[i] - cpm.var.i, size) - lchoose(tot[i], size)
          cpm.var.rare <- exp(cpm.var.rare)
        }
        pd.var <- t(branch.lengths) %*% cpm.var.rare %*% branch.lengths - centering[index]^2
        pd.rare.var[index] <- pd.var
      }
      pd.rare <- data.frame(pd.rare = pd.rare, se = sqrt(pd.rare.var))
    }
    return(data.frame(pd.rare, Size = n, Sample = rownames(x)[i]))
  }
  
  if (parallel) {
    out <- mclapply(seq_len(nr), pdrare, mc.preschedule = FALSE)
  } else {
    out <- lapply(seq_len(nr), pdrare)
  }
  df <- do.call(rbind, out)
  
  ## Get sample data
  if (!is.null(sample_data(physeq, FALSE))) {
    sdf <- as(sample_data(physeq), "data.frame")
    sdf$Sample <- rownames(sdf)
    data <- merge(df, sdf, by = "Sample")
    labels <- data.frame(x = tot, y =  pd, Sample = rownames(x))
    labels <- merge(labels, sdf, by = "Sample")
  }
  
  ## Add, any custom-supplied plot-mapped variables
  if( length(color) > 1 ){
    data$color <- color
    names(data)[names(data)=="color"] <- deparse(substitute(color))
    color <- deparse(substitute(color))
  }
  if( length(label) > 1 ){
    labels$label <- label
    names(labels)[names(labels)=="label"] <- deparse(substitute(label))
    label <- deparse(substitute(label))
  }
  
  p <- ggplot(data = data, aes_string(x = "Size", y = "pd.rare", group = "Sample", color = color))
  if (log) {
    p <- p + scale_x_log10()
  }
  p <- p + labs(x = "Sample Size (# reads)", y = "Phylogenetic Diversity")
  if (!is.null(label)) {
    p <- p + geom_text(data = labels, aes_string(x = "x", y = "y", label = label, color = color),
                       size = 4, hjust = 0)
  }
  p <- p + geom_line()
  if (se) {
    p <- p + geom_ribbon(aes_string(ymin = "pd.rare - se", ymax = "pd.rare + se",
                                    color = NULL, fill = color), alpha = 0.2)
  }
  if (plot) {
    plot(p)
  }
  invisible(p)
}

#' Compute incidence matrix of a tree
#'
#' @title incidenceMatrix
#' @param phy Required. A \code{phylo} class object
#' @return An incidence matrix M of size nedges(tree) x ntaxa(tree) where
#'         M[i,j] is set to 1 if taxa derives from edge i and 0 otherwise.
#' @note incidenceMatrix assumes that the tree is rooted. If not, it roots it
#'       it at an arbitrary taxa (taxa 1). 
incidenceMatrix <- function(phy) {
  if (!is.rooted(phy)) {
    warning("Tree is not rooted, incidence matrix may be meaningless")        
  }
  ## Construct incidence matrix of the tree (taxa x edge matrix)
  ## All taxa descending from an edge are set to 1, all others to -1
  ntaxa <- length(phy$tip.label)
  nedges <- nrow(phy$edge)
  incidence <- matrix (0,
                       nrow = ntaxa,
                       ncol = nedges,
                       dimnames = list(phy$tip.label, phy$edge[, 2]))
  ## Incidence of internal edges
  phy.part <- prop.part(phy) ## clade composition indexed by (shifted) node number
  for (i in 2:length(phy.part)) { ## first clade corresponds to root node
    edge <- which(phy$edge[, 2] == i + ntaxa) ## node numbers are shifted by ntaxa 
    incidence[phy.part[[i]] , edge] <- 1
  }
  ## Incidence of pendant edges
  ## pendant.edges[i] is the edge leading to tip i. 
  pendant.edges <- match(seq_len(ntaxa), phy$edge[ , 2])
  for (i in seq_len(ntaxa)) {
    incidence[i, pendant.edges[i]] <- 1
  }
  attr(incidence, "pendant.edges") <- pendant.edges
  return(incidence)
}

#' Make a rarefaction curve using ggplot2
#' @param physeq_object A phyloseq class object, from which abundance data are extracted
#' @param step Step Size for sample size in rarefaction curves
#' @param label Default `NULL`. Character string. The name of the variable to map to text labels on the plot. Similar to color option but for plotting text.
#' @param color Default `NULL`. Character string. The name of the variable to map to the colors in the plot. This can be a sample variables among the set returned by sample_variables(physeq_object) or taxonomic rank, among the set returned by rank_names(physeq_object)
#' @param plot default `TRUE`. Logical. Should the graph be plotted
#' @param parallel default `FALSE`. Logical. Should rarefaction be parallelized
#' @param se default `TRUE`. Logical. Should standard errors be calculated.
#' @examples
#' good_taxon_table <- data.frame(sum.taxonomy = c("a;b;c;d;f;u", "p;q;r;s;t;u"),
#' site_1 = c(0,1), site_2 = c(10, 20))
#' good_maps <- data.frame(site = c("site_1", "site_2"),
#' season = c("wet", "dry"), host = c("oak", "sage"))
#' physeq_object <- convert_anacapa_to_phyloseq(good_taxon_table, good_maps)
#' ggrare(physeq_object, step = 20, se = TRUE)
#' @export

ggrare <- function(physeq_object, step = 10, label = NULL, color = NULL, plot = TRUE, parallel = FALSE, se = TRUE) {
  
  x <- methods::as(phyloseq::otu_table(physeq_object), "matrix")
  if (phyloseq::taxa_are_rows(physeq_object)) { x <- t(x) }
  
  ## This script is adapted from vegan `rarecurve` function
  tot <- rowSums(x)
  S <- rowSums(x > 0)
  nr <- nrow(x)
  
  rarefun <- function(i) {
    cat(paste("rarefying sample", rownames(x)[i]), sep = "\n")
    n <- seq(1, tot[i], by = step)
    if (n[length(n)] != tot[i]) {
      n <- c(n, tot[i])
    }
    y <- vegan::rarefy(x[i, ,drop = FALSE], n, se = se)
    if (nrow(y) != 1) {
      rownames(y) <- c(".S", ".se")
      return(data.frame(t(y), Size = n, Sample = rownames(x)[i]))
    } else {
      return(data.frame(.S = y[1, ], Size = n, Sample = rownames(x)[i]))
    }
  }
  if (parallel) {
    out <- parallel::mclapply(seq_len(nr), rarefun, mc.preschedule = FALSE)
  } else {
    out <- lapply(seq_len(nr), rarefun)
  }
  df <- do.call(rbind, out)
  
  # Get sample data
  if (!is.null(phyloseq::sample_data(physeq_object, FALSE))) {
    sdf <- methods::as(phyloseq::sample_data(physeq_object), "data.frame")
    sdf$Sample <- rownames(sdf)
    data <- merge(df, sdf, by = "Sample")
    labels <- data.frame(x = tot, y = S, Sample = rownames(x))
    labels <- merge(labels, sdf, by = "Sample")
  }
  
  # Add, any custom-supplied plot-mapped variables
  if ( length(color) > 1 ) {
    data$color <- color
    names(data)[names(data) == "color"] <- deparse(substitute(color))
    color <- deparse(substitute(color))
  }
  
  if ( length(label) > 1 ) {
    labels$label <- label
    names(labels)[names(labels) == "label"] <- deparse(substitute(label))
    label <- deparse(substitute(label))
  }
  
  p <- ggplot2::ggplot(data = data,
                       ggplot2::aes_string(x = "Size",
                                           y = ".S",
                                           group = "Sample",
                                           color = color))
  
  p <- p + ggplot2::labs(x = "Sequence Sample Size", y = "Species Richness")
  
  if (!is.null(label)) {
    p <- p + ggplot2::geom_text(data = labels,
                                ggplot2::aes_string(x = "x",
                                                    y = "y",
                                                    label = label,
                                                    color = color),
                                size = 4, hjust = 0)
  }
  
  p <- p + ggplot2::geom_line()
  if (se) { ## add standard error if available
    p <- p +
      ggplot2::geom_ribbon(ggplot2::aes_string(ymin = ".S - .se",
                                               ymax = ".S + .se",
                                               color = NULL,
                                               fill = color),
                           alpha = 0.2)
  }
  if (plot) {
    plot(p)
  }
  invisible(p)
}


pheat_map_batch <- function(ps_obj,cols_int,annotation_colors,title="Combat correction"){
  ps_obj_meta <- sample_data(ps_obj)
  meta_for_heatmap <- ps_obj_meta[, (names(ps_obj_meta) %in% cols_of_interest)]
  meta_for_heatmap <- as(meta_for_heatmap, 'data.frame')
  data.scale <- scale(ps_obj@otu_table, center = T, scale = T) 
  data.scale <- scale(t(data.scale), center = T, scale = T) 
  fig <- pheatmap( 
    (data.scale), 
    cluster_rows = F, 
    cluster_cols = T,
    fontsize_row = 12, fontsize_col = 10,
    fontsize = 25,
    clustering_distance_rows = 'euclidean',
    clustering_method = 'ward.D',
    treeheight_row = 15,
    annotation_col = meta_for_heatmap,
    annotation_colors = annotation_colors,
    # col= hmcols, 
    # breaks = bk,
    main=title)
  return(fig)
}


replace_otu_fun <- function(ps_obj,otu_table,taxa_are_rows){
  if (taxa_are_rows == F){
    otu_table(ps_obj) <- otu_table(otu_table,taxa_are_rows = F)
  }
  if (taxa_are_rows == T){
    otu_table(ps_obj) <- otu_table(t(otu_table),taxa_are_rows = T)}
  return(ps_obj)}


plot_ordination_utils <- function(x,
                                  ordiObject,
                                  color.opt = NULL,
                                  shape.opt = NULL,
                                  names = NULL,
                                  taxa_size = NULL,
                                  point_size = NULL,
                          
                                  plot.arrow = TRUE,
                                  scale.arrow = NULL,
                                  top.taxa = 5) {
  p.base <-
    y.axis <-
    x.axis <-
    pdf.sam <-
    pdf.tax <-
    pdf.tax2 <-
    id.type <-
    best_hit <-
    select.top <- dif.tax.ord <- pdf.tax3 <- plot.ord.load <- NULL
  p.base <- plot_ordination(x, ordiObject,
                            color = color.opt,
                            shape = shape.opt,
                            type = "split"
  )
  y.axis <- p.base$labels$y[1]
  x.axis <- p.base$labels$x[1]
  pdf.base <- p.base$data
  # unique(pdf$id.type)
  pdf.sam <- subset(pdf.base, id.type == "Samples")
  pdf.tax <- subset(pdf.base, id.type == "Taxa")
  rownames(pdf.tax) <- pdf.tax$best_hit
  pdf.tax2 <- pdf.tax[, 1:2]
  select.top <- min(top.taxa, dim(pdf.tax2)[1])
  diff.taxa.ord <- names(sort(apply(abs(pdf.tax2), 1, max),
                              decreasing = T
  ))[1:select.top]
  pdf.tax3 <- subset(pdf.tax, best_hit %in% diff.taxa.ord)
  
    plot.ord.load <-
      ggplot() + geom_text(aes(pdf.sam
                               [
                                 ,
                                 1
                               ], pdf.sam[, 2]),label = pdf.sam[, names],size=point_size)+
      geom_point(
        data = pdf.sam,
        aes(pdf.sam
            [
              ,
              1
            ], pdf.sam[, 2], color = pdf.sam[, color.opt],shape =  pdf.sam[, shape.opt],size=6)
      ) + guides(shape = guide_legend(override.aes = list(size = 20)))

 
    plot.ord.load <- plot.ord.load + ggrepel::geom_text_repel(
      data = pdf.tax3,
      aes(scale.arrow * pdf.tax3[, 1], scale.arrow * pdf.tax3
          [
            ,
            2
          ], label = best_hit,color = 'taxa'),size=taxa_size) #+ 
    #+ ggrepel::geom_text_repel(size=10)
    if (plot.arrow == TRUE) {
      plot.ord.load <- plot.ord.load + geom_segment(
        data = pdf.tax3,
        aes(
          x = 0,
          xend = scale.arrow * pdf.tax3[, 1],
          y = 0,
          yend = scale.arrow * pdf.tax3[, 2]
        ),
        arrow = arrow(length = unit(
          0.4,
          "cm"
        )),size = 0.5, 
        color = "black"
      )
      plot.ord.load <- plot.ord.load + theme_bw() + xlab(x.axis) +
        ylab(y.axis)
      return(plot.ord.load)
    } else {
      plot.ord.load <- plot.ord.load + theme_bw() + xlab(x.axis) +
        ylab(y.axis)
      return(plot.ord.load)
    }
  }
   
  
